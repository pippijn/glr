option shift_reduce_conflicts 149;
option reduce_reduce_conflicts 216;
option unreachable_nonterminals 1;
option unreachable_terminals 8;

verbatim {
open CcTreematch.Ptree;;
}

impl_verbatim {
open CcTreematch.Ptree;;
}

terminals {
  150 : TOK_IMAGINARY "_Imaginary";
  149 : TOK_COMPLEX "_Complex";
  148 : TOK_RESTRICT "restrict";
  147 : TOK_IMAG "__imag__";
  146 : TOK_REAL "__real__";
  145 : TOK_MAX_OP ">?";
  144 : TOK_MIN_OP "<?";
  143 : TOK___EXTENSION__ "__extension__";
  142 : TOK___TYPEOF__ "__typeof__";
  141 : TOK___PRETTY_FUNCTION__ "__PRETTY_FUNCTION__";
  140 : TOK___LABEL__ "__label__";
  139 : TOK___FUNCTION__ "__FUNCTION__";
  138 : TOK___ATTRIBUTE__ "__attribute__";
  137 : TOK___BUILTIN_OFFSETOF "__builtin_offsetof";
  136 : TOK___OFFSETOF__ "__offsetof__";
  135 : TOK___ALIGNOF__ "__alignof__";
  134 : TOK___BUILTIN_VA_ARG "__builtin_va_arg";
  133 : TOK___BUILTIN_CONSTANT_P "__builtin_constant_p";
  132 : TOK_CHAR32_t "char32_t";
  131 : TOK_CHAR16_t "char16_t";
  130 : TOK_STATIC_ASSERT "static_assert";
  129 : TOK_NULLPTR "nullptr";
  128 : TOK_ALIGNOF "alignof";
  127 : TOK_DECLTYPE "decltype";
  126 : TOK_NOEXCEPT "noexcept";
  125 : TOK_CONSTEXPR "constexpr";
  124 : TOK_PREFER_SHIFT "<prefer shift>";
  123 : TOK_PREFER_REDUCE "<prefer reduce>";
  122 : TOK_ANNOTATION;
  121 : TOK_RBRACE "}";
  120 : TOK_LBRACE "{";
  119 : TOK_SEMICOLON ";";
  118 : TOK_ELLIPSIS "...";
  117 : TOK_COMMA ",";
  116 : TOK_RIGHTSHIFTEQUAL ">>=";
  115 : TOK_LEFTSHIFTEQUAL "<<=";
  114 : TOK_OREQUAL "|=";
  113 : TOK_XOREQUAL "^=";
  112 : TOK_ANDEQUAL "&=";
  111 : TOK_MINUSEQUAL "-=";
  110 : TOK_PLUSEQUAL "+=";
  109 : TOK_PERCENTEQUAL "%=";
  108 : TOK_SLASHEQUAL "/=";
  107 : TOK_STAREQUAL "*=";
  106 : TOK_EQUAL "=";
  105 : TOK_COLON ":";
  104 : TOK_QUESTION "?";
  103 : TOK_OROR "||";
  102 : TOK_ANDAND "&&";
  101 : TOK_OR "|";
  100 : TOK_XOR "^";
   99 : TOK_NOTEQUAL "!=";
   98 : TOK_EQUALEQUAL "==";
   97 : TOK_GREATEREQ ">=";
   96 : TOK_GREATERTHAN ">";
   95 : TOK_LESSEQ "<=";
   94 : TOK_LESSTHAN "<";
   93 : TOK_RIGHTSHIFT ">>";
   92 : TOK_LEFTSHIFT "<<";
   91 : TOK_PERCENT "%";
   90 : TOK_SLASH "/";
   89 : TOK_ARROWSTAR "->*";
   88 : TOK_DOTSTAR ".*";
   87 : TOK_STAR "*";
   86 : TOK_AND "&";
   85 : TOK_MINUSMINUS "--";
   84 : TOK_PLUSPLUS "++";
   83 : TOK_MINUS "-";
   82 : TOK_PLUS "+";
   81 : TOK_TILDE "~";
   80 : TOK_BANG "!";
   79 : TOK_DOT ".";
   78 : TOK_COLONCOLON "::";
   77 : TOK_ARROW "->";
   76 : TOK_RBRACKET "]";
   75 : TOK_LBRACKET "[";
   74 : TOK_RPAREN ")";
   73 : TOK_LPAREN "(";
   72 : TOK_WHILE "while";
   71 : TOK_WCHAR_T "wchar_t";
   70 : TOK_VOLATILE "volatile";
   69 : TOK_VOID "void";
   68 : TOK_VIRTUAL "virtual";
   67 : TOK_USING "using";
   66 : TOK_UNSIGNED "unsigned";
   65 : TOK_UNION "union";
   64 : TOK_TYPENAME "typename";
   63 : TOK_TYPEID "typeid";
   62 : TOK_TYPEDEF "typedef";
   61 : TOK_TRY "try";
   60 : TOK_TRUE "true";
   59 : TOK_THROW "throw";
   58 : TOK_THIS "this";
   57 : TOK_TEMPLATE "template";
   56 : TOK_SWITCH "switch";
   55 : TOK_STRUCT "struct";
   54 : TOK_STATIC_CAST "static_cast";
   53 : TOK_STATIC "static";
   52 : TOK_SIZEOF "sizeof";
   51 : TOK_SIGNED "signed";
   50 : TOK_SHORT "short";
   49 : TOK_RETURN "return";
   48 : TOK_REINTERPRET_CAST "reinterpret_cast";
   47 : TOK_REGISTER "register";
   46 : TOK_PUBLIC "public";
   45 : TOK_PROTECTED "protected";
   44 : TOK_PRIVATE "private";
   43 : TOK_PASCAL "pascal";
   42 : TOK_OPERATOR "operator";
   41 : TOK_NEW "new";
   40 : TOK_NAMESPACE "namespace";
   39 : TOK_MUTABLE "mutable";
   38 : TOK_LONG "long";
   37 : TOK_INT "int";
   36 : TOK_INLINE "inline";
   35 : TOK_IF "if";
   34 : TOK_GOTO "goto";
   33 : TOK_FRIEND "friend";
   32 : TOK_FOR "for";
   31 : TOK_FLOAT "float";
   30 : TOK_FALSE "false";
   29 : TOK_EXTERN "extern";
   28 : TOK_EXPORT "export";
   27 : TOK_EXPLICIT "explicit";
   26 : TOK_ENUM "enum";
   25 : TOK_ELSE "else";
   24 : TOK_DYNAMIC_CAST "dynamic_cast";
   23 : TOK_DOUBLE "double";
   22 : TOK_DO "do";
   21 : TOK_DELETE "delete";
   20 : TOK_DEFAULT "default";
   19 : TOK_CONTINUE "continue";
   18 : TOK_CONST_CAST "const_cast";
   17 : TOK_CONST "const";
   16 : TOK_CLASS "class";
   15 : TOK_CHAR "char";
   14 : TOK_CDECL "cdecl";
   13 : TOK_CATCH "catch";
   12 : TOK_CASE "case";
   11 : TOK_BOOL "bool";
   10 : TOK_BREAK "break";
    9 : TOK_AUTO "auto";
    8 : TOK_ASM "asm";
    7 : TOK_CHAR_LITERAL;
    6 : TOK_STRING_LITERAL;
    5 : TOK_FLOAT_LITERAL;
    4 : TOK_INT_LITERAL;
    3 : TOK_VARIABLE_NAME;
    2 : TOK_TYPE_NAME;
    1 : TOK_NAME;
    0 : TOK_EOF "<EOF>";


  (* all literals are yielded as their syntax strings *)
  token(string) TOK_INT_LITERAL;
  token(string) TOK_FLOAT_LITERAL;
  token(string) TOK_CHAR_LITERAL;
  token(string) TOK_STRING_LITERAL;

  (* similar for identifiers *)
  token(string) TOK_NAME;
  token(string) TOK_TYPE_NAME;
  token(string) TOK_VARIABLE_NAME;

  (* and annotations *)
  token(string) TOK_ANNOTATION;


  precedence {
    prec 190 TOK_RESTRICT;
    left 80 TOK_MAX_OP;
    left 80 TOK_MIN_OP;
    prec 190 TOK___ATTRIBUTE__;
    prec 1 TOK_PREFER_SHIFT;
    prec 200 TOK_PREFER_REDUCE;
    left 20 TOK_OROR;
    left 30 TOK_ANDAND;
    left 40 TOK_OR;
    left 50 TOK_XOR;
    left 70 TOK_NOTEQUAL;
    left 70 TOK_EQUALEQUAL;
    left 90 TOK_RIGHTSHIFT;
    left 90 TOK_LEFTSHIFT;
    left 110 TOK_PERCENT;
    left 110 TOK_SLASH;
    left 120 TOK_ARROWSTAR;
    left 120 TOK_DOTSTAR;
    left 110 TOK_STAR;
    left 60 TOK_AND;
    left 100 TOK_MINUS;
    left 100 TOK_PLUS;
    right 195 TOK_COLONCOLON;
    prec 190 TOK_LBRACKET;
    prec 190 TOK_VOLATILE;
    prec 190 TOK_ELSE;
    prec 190 TOK_CONST;
  }
}

nonterm(int) File {
  -> t:TranslationUnit { 0 }
}

nonterm AbstractDeclarator {
  -> d:DirectAbstractDeclarator attr:AttributeSpecifierList [AttrDirect] { 0 }
  -> p:PrefixDeclarator d:AbstractDeclaratorOpt [Prefixed] { 0 }
  -> d:DirectAbstractDeclarator [Direct] { 0 }
  -> "*" cv:CVQualifierSeqOpt attrspec:AttributeSpecifier cv2:CVQualAttrSeqOpt d:AbstractDeclaratorOpt [Attr] { 0 }
}

nonterm AbstractDeclaratorOpt {
  -> empty { 0 }
  -> d:AbstractDeclarator { 0 }
}

nonterm AccessSpecifier {
  -> "public" [Public] { 0 }
  -> "private" [Private] { 0 }
  -> "protected" [Protected] { 0 }
}

nonterm AccessSpecifierOpt {
  -> empty { 0 }
  -> k:AccessSpecifier { 0 }
}

nonterm AnnotatedStatement {
  -> s:Statement a:AnnotationOpt [Stmt] { 0 }
}

nonterm AnnotationList {
  -> a:TOK_ANNOTATION { 0 }
  -> l:AnnotationList a:TOK_ANNOTATION { 0 }
}

nonterm AnnotationOpt {
  -> empty { 0 }
  -> a:AnnotationList { 0 }
}

nonterm ArgumentList {
  -> "(" e:ExpressionListOpt ")" { 0 }
}

nonterm AsmDefinition {
  -> "asm" "(" s:StringLiteral ocs:NonemptyOpConstraints ")" ";" [Constrained] { 0 }
  -> "asm" q:CVQualifierSeq "(" s:StringLiteral ")" ";" [Qualified] { 0 }
  -> "asm" "(" s:StringLiteral ")" ";" [Standard] { 0 }
  -> "asm" q:CVQualifierSeq "(" s:StringLiteral ocs:NonemptyOpConstraints ")" ";" [QualifiedConstrained] { 0 }
}

nonterm AssignmentExpression {
  fun merge (l, r) { 0 }
  -> e:ConditionalExpression [ConditionalExpression] { 0 }
  -> e1:BinaryExpression op:AssignmentOperator e2:AssignmentExpression [Assign] { 0 }
  -> e:ThrowExpression [Throw] { 0 }
}

nonterm AssignmentOperator {
  -> "*=" [MulAssign] { 0 }
  -> "/=" [DivAssign] { 0 }
  -> "%=" [ModAssign] { 0 }
  -> "+=" [AddAssign] { 0 }
  -> "-=" [SubAssign] { 0 }
  -> ">>=" [RshAssign] { 0 }
  -> "<<=" [LshAssign] { 0 }
  -> "&=" [BitAndAssign] { 0 }
  -> "^=" [BitXorAssign] { 0 }
  -> "|=" [BitOrAssign] { 0 }
  -> "=" [Assign] { 0 }
}

nonterm Attribute {
  -> empty [Empty] { 0 }
  -> w:AttributeWord [Word] { 0 }
  -> w:AttributeWord "(" ap:AttributeParameters ")" [Func] { 0 }
}

nonterm AttributeList {
  -> at:Attribute [Head] { 0 }
  -> at:Attribute "," ap:AttributeList [Tail] { 0 }
}

nonterm AttributeParameters {
  -> exprs:CommaSepExpressionListOpt { 0 }
}

nonterm AttributeSpecifier {
  -> "__attribute__" "(" "(" ap:AttributeList ")" ")" { 0 }
}

nonterm AttributeSpecifierList {
  -> s:AttributeSpecifier [Head] { 0 }
  -> s:AttributeSpecifier sl:AttributeSpecifierList [Tail] { 0 }
}

nonterm AttributeWord {
  -> n:TOK_NAME [Identifier] { 0 }
  -> "asm" [Asm] { 0 }
  -> "auto" [Auto] { 0 }
  -> "break" [Break] { 0 }
  -> "bool" [Bool] { 0 }
  -> "case" [Case] { 0 }
  -> "catch" [Catch] { 0 }
  -> "cdecl" [Cdecl] { 0 }
  -> "char" [Char] { 0 }
  -> "class" [Class] { 0 }
  -> "const" [Const] { 0 }
  -> "const_cast" [ConstCast] { 0 }
  -> "continue" [Continue] { 0 }
  -> "default" [Default] { 0 }
  -> "delete" [Delete] { 0 }
  -> "do" [Do] { 0 }
  -> "double" [Double] { 0 }
  -> "dynamic_cast" [DynamicCast] { 0 }
  -> "else" [Else] { 0 }
  -> "enum" [Enum] { 0 }
  -> "explicit" [Explicit] { 0 }
  -> "export" [Export] { 0 }
  -> "extern" [Extern] { 0 }
  -> "false" [False] { 0 }
  -> "float" [Float] { 0 }
  -> "for" [For] { 0 }
  -> "friend" [Friend] { 0 }
  -> "goto" [Goto] { 0 }
  -> "if" [If] { 0 }
  -> "inline" [Inline] { 0 }
  -> "int" [Int] { 0 }
  -> "long" [Long] { 0 }
  -> "mutable" [Mutable] { 0 }
  -> "namespace" [Namespace] { 0 }
  -> "new" [New] { 0 }
  -> "operator" [Operator] { 0 }
  -> "pascal" [Pascal] { 0 }
  -> "private" [Private] { 0 }
  -> "protected" [Protected] { 0 }
  -> "public" [Public] { 0 }
  -> "register" [Register] { 0 }
  -> "reinterpret_cast" [ReinterpretCast] { 0 }
  -> "return" [Return] { 0 }
  -> "short" [Short] { 0 }
  -> "signed" [Signed] { 0 }
  -> "sizeof" [Sizeof] { 0 }
  -> "static" [Static] { 0 }
  -> "static_cast" [StaticCast] { 0 }
  -> "struct" [Struct] { 0 }
  -> "switch" [Switch] { 0 }
  -> "template" [Template] { 0 }
  -> "this" [This] { 0 }
  -> "throw" [Throw] { 0 }
  -> "true" [True] { 0 }
  -> "try" [Try] { 0 }
  -> "typedef" [Typedef] { 0 }
  -> "typeid" [Typeid] { 0 }
  -> "typename" [Typename] { 0 }
  -> "union" [Union] { 0 }
  -> "unsigned" [Unsigned] { 0 }
  -> "using" [Using] { 0 }
  -> "virtual" [Virtual] { 0 }
  -> "void" [Void] { 0 }
  -> "volatile" [Volatile] { 0 }
  -> "wchar_t" [WcharT] { 0 }
  -> "while" [While] { 0 }
}

nonterm BaseClauseOpt {
  -> empty { 0 }
  -> ":" b:BaseSpecifierList { 0 }
}

nonterm BaseSpecifier {
  -> cname:PQClassName [Base] { 0 }
  -> "virtual" access:AccessSpecifierOpt cname:PQClassName [VirtualBase] { 0 }
  -> access:AccessSpecifier is_virtual:VirtualOpt cname:PQClassName [AccessBase] { 0 }
}

nonterm BaseSpecifierList {
  fun merge (l, r) { 0 }
  -> b:BaseSpecifier [Head] { 0 }
  -> list:BaseSpecifierList "," b:BaseSpecifier [Tail] { 0 }
}

nonterm BinExp_high {
  fun merge (l, r) { 0 }
  -> e:CastExpression [CastExpression] { 0 }
  -> left:BinExp_high ".*" right:BinExp_high [DotStar] { 0 }
  -> left:BinExp_high "->*" right:BinExp_high [ArrowStar] { 0 }
  -> left:BinExp_high "*" right:BinExp_high [Mul] { 0 }
  -> left:BinExp_high "/" right:BinExp_high [Div] { 0 }
  -> left:BinExp_high "%" right:BinExp_high [Mod] { 0 }
  -> left:BinExp_high "+" right:BinExp_high [Add] { 0 }
  -> left:BinExp_high "-" right:BinExp_high [Sub] { 0 }
  -> left:BinExp_high "<<" right:BinExp_high [Lsh] { 0 }
  -> left:BinExp_high ">>" right:BinExp_high [Rsh] { 0 }
}

nonterm BinExp_low {
  fun merge (l, r) { 0 }
  -> e:BinExp_mid [BinExp_mid] { 0 }
  -> left:BinExp_low "==" right:BinExp_low [Equal] { 0 }
  -> left:BinExp_low "!=" right:BinExp_low [NotEqual] { 0 }
  -> left:BinExp_low "&" right:BinExp_low [BitAnd] { 0 }
  -> left:BinExp_low "^" right:BinExp_low [BitXor] { 0 }
  -> left:BinExp_low "|" right:BinExp_low [BitOr] { 0 }
  -> left:BinExp_low "&&" right:BinExp_low [Or] { 0 }
  -> left:BinExp_low "||" right:BinExp_low [And] { 0 }
}

nonterm BinExp_mid {
  fun merge (l, r) { 0 }
  -> left:BinExp_mid ">?" right:BinExp_high [Max] { 0 }
  -> e:BinExp_high [BinExp_high] { 0 }
  -> left:BinExp_mid "<" right:BinExp_high [Less] { 0 }
  -> left:BinExp_mid ">" right:BinExp_high [Greater] { 0 }
  -> left:BinExp_mid "<=" right:BinExp_high [LessEq] { 0 }
  -> left:BinExp_mid ">=" right:BinExp_high [GreaterEq] { 0 }
  -> left:BinExp_mid "<?" right:BinExp_high [Min] { 0 }
}

nonterm BinaryExpression {
  -> e:BinExp_low { 0 }
}

nonterm BlockDeclaration {
  -> d:SimpleDeclaration { 0 }
}

nonterm BracketedWordOpt {
  -> empty { 0 }
  -> "[" id:Identifier "]" { 0 }
}

nonterm BuggyGccTypeModifier {
  -> "long" { 0 }
  -> "short" { 0 }
  -> "signed" { 0 }
  -> "unsigned" { 0 }
  -> "long" BuggyGccTypeModifier { 0 }
  -> "short" BuggyGccTypeModifier { 0 }
  -> "signed" BuggyGccTypeModifier { 0 }
  -> "unsigned" BuggyGccTypeModifier { 0 }
}

nonterm CDtorModifier {
  -> attr:AttributeSpecifier [Attr] { 0 }
  -> "explicit" [Explicit] { 0 }
  -> "virtual" [Virtual] { 0 }
  -> "inline" [Inline] { 0 }
  -> "friend" [Friend] { 0 }
  -> "constexpr" [Constexpr] { 0 }
}

nonterm CDtorModifierSeq {
  -> m:CDtorModifier { 0 }
  -> s:CDtorModifierSeq m:CDtorModifier { 0 }
}

nonterm CDtorProtoDecl {
  -> dflags:CDtorModifierSeq d:MemberDeclarator ";" [ModDecl] { 0 }
  -> d:MemberDeclarator ";" [Decl] { 0 }
}

nonterm CFuncModifier {
  -> m:CFuncModifier_no_inline [NoInline] { 0 }
  -> "inline" [Inline] { 0 }
}

nonterm CFuncModifierSeq {
  -> m:CFuncModifier { 0 }
  -> s:CFuncModifierSeq m:CFuncModifier { 0 }
}

nonterm CFuncModifierSeqOpt {
  -> empty { 0 }
  -> m:CFuncModifierSeq { 0 }
}

nonterm CFuncModifier_no_inline {
  -> "static" [Static] { 0 }
  -> "extern" [Extern] { 0 }
  -> "const" [Const] { 0 }
  -> "volatile" [Volatile] { 0 }
}

nonterm CVQualAttr {
  -> q:CVQualifier [Cv] { 0 }
  -> AttributeSpecifier [Attr] { 0 }
}

nonterm CVQualAttrSeq {
  -> q:CVQualAttr [Head] { 0 }
  -> q:CVQualAttr s:CVQualAttrSeq [Tail] { 0 }
}

nonterm CVQualAttrSeqOpt {
  -> empty { 0 }
  -> s:CVQualAttrSeq { 0 }
}

nonterm CVQualifier {
  -> "restrict" [Restrict] { 0 }
  -> "volatile" [Volatile] { 0 }
  -> "const" [Const] { 0 }
}

nonterm CVQualifierSeq {
  -> q:CVQualifier { 0 }
  -> s:CVQualifierSeq q:CVQualifier { 0 }
}

nonterm CVQualifierSeqOpt {
  -> empty { 0 }
  -> s:CVQualifierSeq { 0 }
}

nonterm CastExpression {
  fun merge (l, r) { 0 }
  -> "(" t:ImplicitIntTypeId ")" e:CastExpression [ImplInt] { 0 }
  -> "(" t:TypeId ")" e:CastExpression [Cast] { 0 }
  -> e:UnaryExpression [UnaryExpression] { 0 }
}

nonterm CastKeyword {
  -> "dynamic_cast" [DynamicCast] { 0 }
  -> "static_cast" [StaticCast] { 0 }
  -> "reinterpret_cast" [ReinterpretCast] { 0 }
  -> "const_cast" [ConstCast] { 0 }
}

nonterm ClassHeadName {
  fun merge (l, r) { 0 }
  -> n:Identifier [Id] { 0 }
  -> t:TemplateId [TemplateId] { 0 }
  -> n:Identifier "::" rest:ClassHeadName [Qualified] { 0 }
  -> n:Identifier "<" targs:TemplateArgumentListOpt ">" "::" rest:ClassHeadName [QualifiedTemplate] { 0 }
  -> "template" n:Identifier "<" targs:TemplateArgumentListOpt ">" "::" rest:ClassHeadName [TemplateQualified] { 0 }
}

nonterm ClassHeadNameOpt {
  fun merge (l, r) { 0 }
  -> empty [None] { 0 }
  -> n:ClassHeadName [Some] { 0 }
}

nonterm ClassKey {
  -> "class" [Class] { 0 }
  -> "struct" [Struct] { 0 }
  -> "union" [Union] { 0 }
}

nonterm ClassOrTypename {
  -> "class" { 0 }
  -> "typename" { 0 }
}

nonterm ClassSpecifier {
  -> k:ClassKey s:AttributeSpecifierList n:ClassHeadNameOpt b:BaseClauseOpt "{" memb:MemberDeclarationSeqOpt "}" [ClassSpecAttr] { 0 }
  -> k:ClassKey n:ClassHeadNameOpt b:BaseClauseOpt "{" memb:MemberDeclarationSeqOpt "}" [ClassSpec] { 0 }
}

nonterm ColonColonOpt {
  -> empty { 0 }
  -> "::" { 0 }
}

nonterm CommaOpt {
  -> empty { 0 }
  -> "," { 0 }
}

nonterm CommaSepExpressionListOpt {
  -> empty { 0 }
  -> el:ExpressionList { 0 }
}

nonterm CompoundInitialiser {
  -> "{" "}" { 0 }
  -> "{" list:InitialiserList CommaOpt "}" { 0 }
}

nonterm CompoundStatement {
  -> "{" seq:CompoundStmtHelper lesl:LabelledEmptyStatementList "}" [EndsInLabel] { 0 }
  -> "{" seq:CompoundStmtHelper "}" [CompoundStmt] { 0 }
}

nonterm CompoundStmtHelper {
  -> empty { 0 }
  -> c:CompoundStmtHelper s:AnnotatedStatement { 0 }
}

nonterm Condition {
  fun merge (l, r) { 0 }
  -> e:Expression [ExprCond] { 0 }
  -> spec:TypeSpecifier decl:Declarator "=" e:AssignmentExpression [DeclCond] { 0 }
}

nonterm ConditionOpt {
  -> empty { 0 }
  -> c:Condition { 0 }
}

nonterm ConditionalExpression {
  fun merge (l, r) { 0 }
  -> cond:BinaryExpression "?" ":" el:AssignmentExpression [ConditionalNoThen] { 0 }
  -> cond:BinaryExpression "?" th:Expression ":" el:AssignmentExpression [Conditional] { 0 }
  -> e:BinaryExpression [BinaryExpression] { 0 }
}

nonterm ConstantExpression {
  -> e:AssignmentExpression { 0 }
}

nonterm ConstantExpressionOpt {
  -> empty { 0 }
  -> e:ConstantExpression { 0 }
}

nonterm ConversionDeclarator {
  -> p:PrefixDeclarator d:ConversionDeclaratorOpt [ConvDecl] { 0 }
}

nonterm ConversionDeclaratorOpt {
  -> empty { 0 }
  -> d:ConversionDeclarator { 0 }
}

nonterm ConversionFunctionId {
  -> "operator" t:ConversionTypeId { 0 }
}

nonterm ConversionTypeId {
  -> s:TypeSpecifier d:ConversionDeclaratorOpt [ConvType] { 0 }
}

nonterm CtorExpressionType {
  -> n:PQTypeName [TypeName] { 0 }
  -> "char" [Char] { 0 }
  -> "wchar_t" [WCharT] { 0 }
  -> "bool" [Bool] { 0 }
  -> "short" [Short] { 0 }
  -> "int" [Int] { 0 }
  -> "long" [Long] { 0 }
  -> "signed" [Signed] { 0 }
  -> "unsigned" [Unsigned] { 0 }
  -> "float" [Float] { 0 }
  -> "double" [Double] { 0 }
  -> "void" [Void] { 0 }
}

nonterm CtorInitialiserOpt {
  -> empty { 0 }
  -> ":" list:MemInitialiserList { 0 }
}

nonterm DeclSpecifier {
  -> m1:UberModifierSeq n:PQTypeName BuggyGccTypeModifier m2:UberModifierSeqOpt [ModModifiedTypedef] { 0 }
  -> m1:UberModifierSeq te:TypeofTypeSpecifier m2:UberModifierSeqOpt [ModTypeof] { 0 }
  -> m1:UberModifierSeq te:DecltypeTypeSpecifier m2:UberModifierSeqOpt [ModDecltype] { 0 }
  -> n:PQTypeName m2:UberModifierSeqOpt [Name] { 0 }
  -> m1:UberModifierSeq n:PQTypeName m2:UberModifierSeqOpt [ModName] { 0 }
  -> k1:SimpleTypeSpecifier m2:UberTypeAndModifierSeqOpt [Simple] { 0 }
  -> m1:UberModifierSeq k1:SimpleTypeSpecifier m2:UberTypeAndModifierSeqOpt [ModSimple] { 0 }
  -> e:ElaboratedOrSpecifier m2:UberModifierSeqOpt [Elab] { 0 }
  -> m1:UberModifierSeq e:ElaboratedOrSpecifier m2:UberModifierSeqOpt [ModElab] { 0 }
  -> te:DecltypeTypeSpecifier m2:UberModifierSeqOpt [Decltype] { 0 }
  -> te:TypeofTypeSpecifier m2:UberModifierSeqOpt [Typeof] { 0 }
  -> n:PQTypeName BuggyGccTypeModifier m2:UberModifierSeqOpt [ModifiedTypedef] { 0 }
}

nonterm Declaration {
  fun merge (l, r) { 0 }
  -> m1:UberModifierSeqOpt list:InitDeclaratorList ";" [ImplIntDecls] { 0 }
  -> k:KandRFunctionDefinition_implInt [ImplIntFunction] { 0 }
  -> e:EmptyDeclaration [Empty] { 0 }
  -> d:BlockDeclaration [Block] { 0 }
  -> f:FunctionDefinition [Function] { 0 }
  -> t:TemplateDeclaration [Template] { 0 }
  -> d:ExplicitInstantiation [ExplInst] { 0 }
  -> s:LinkageSpecification [LinkageSpec] { 0 }
  -> a:AsmDefinition [Asm] { 0 }
  -> n:NamespaceDefinition [NamespaceDefn] { 0 }
  -> n:NamespaceDecl [NamespaceDecl] { 0 }
  -> k:KandRFunctionDefinition [KandrFunction] { 0 }
  -> f:ImplIntFunctionDefinition [ImplIntFunDef] { 0 }
}

nonterm Declarator {
  -> d:DirectDeclarator attr:AttributeSpecifierList [AttrDirect] { 0 }
  -> d:DirectDeclarator "asm" "(" reg:StringLiteral ")" attr:AttributeSpecifierList [AsmAttr] { 0 }
  -> p:PrefixDeclarator d:Declarator [Prefix] { 0 }
  -> d:DirectDeclarator [Direct] { 0 }
  -> d:DirectDeclarator "asm" "(" reg:StringLiteral ")" [Asm] { 0 }
  -> "*" cv:CVQualifierSeqOpt attr:AttributeSpecifier cv2:CVQualAttrSeqOpt d:Declarator [Attr] { 0 }
}

nonterm DecltypeExpr {
  -> "decltype" "(" e:Expression ")" { 0 }
}

nonterm DecltypeType {
  -> "decltype" "(" t:TypeId ")" { 0 }
}

nonterm DecltypeTypeSpecifier {
  fun merge (l, r) { 0 }
  -> e:DecltypeExpr [DeclTypeExpr] { 0 }
  -> t:DecltypeType [DeclTypeType] { 0 }
}

nonterm DefaultTemplateOpt {
  -> empty { 0 }
  -> "=" t:IdExpression { 0 }
}

nonterm DefaultTypeOpt {
  -> empty { 0 }
  -> "=" t:TypeId { 0 }
}

nonterm DefaultValueOpt {
  -> empty { 0 }
  -> "=" e:AssignmentExpression { 0 }
}

nonterm DeleteExpression {
  -> c:ColonColonOpt "delete" e:CastExpression [Delete] { 0 }
  -> c:ColonColonOpt "delete" "[" "]" e:CastExpression [DeleteArray] { 0 }
}

nonterm Designator {
  -> "." id:Identifier [Name] { 0 }
  -> "[" idx_expr:ConstantExpression "]" [Array] { 0 }
  -> "[" idx_expr:ConstantExpression "..." idx_expr2:ConstantExpression "]" [Range] { 0 }
}

nonterm DesignatorList {
  -> d:Designator [Head] { 0 }
  -> d:Designator dl:DesignatorList [Tail] { 0 }
}

nonterm DirectAbstractDeclarator {
  fun merge (l, r) { 0 }
  -> "(" attr:AttributeSpecifierList d:AbstractDeclarator ")" [Attr] { 0 }
  -> d:DirectAbstractDeclaratorOpt "(" args:ParameterDeclarationClause ")" cv:CVQualifierSeqOpt e:ExceptionSpecificationOpt [Func] { 0 }
  -> d:DirectAbstractDeclaratorOpt "[" sz:ConstantExpressionOpt "]" [Array] { 0 }
  -> "(" d:AbstractDeclarator ")" [Grouping] { 0 }
  -> d:DirectAbstractDeclaratorOpt "[" q:CVQualifierSeq "]" [QualArray] { 0 }
}

nonterm DirectAbstractDeclaratorOpt {
  -> empty { 0 }
  -> d:DirectAbstractDeclarator { 0 }
}

nonterm DirectDeclarator {
  -> "(" attr:AttributeSpecifierList d:Declarator ")" [Attr] { 0 }
  -> n:IdExpression [IdDecl] { 0 }
  -> n:PQDtorName [DtorDecl] { 0 }
  -> d:DirectDeclarator "(" params:ParameterDeclarationClause ")" cv:CVQualifierSeqOpt e:ExceptionSpecificationOpt [FuncDecl] { 0 }
  -> d:DirectDeclarator "[" sz:ConstantExpressionOpt "]" [ArrayDecl] { 0 }
  -> "(" d:Declarator ")" [ParenDecl] { 0 }
  -> d:DirectDeclarator "[" q:CVQualifierSeq "]" [QualArray] { 0 }
}

nonterm DirectNewDeclarator {
  -> "[" sz:Expression "]" [Array] { 0 }
  -> d:DirectNewDeclarator "[" sz:ConstantExpression "]" [ConstArray] { 0 }
}

nonterm ElaboratedOrSpecifier {
  -> s:ElaboratedTypeSpecifier [Elab] { 0 }
  -> s:ClassSpecifier [Class] { 0 }
  -> s:EnumSpecifier [Enum] { 0 }
}

nonterm ElaboratedTypeSpecifier {
  -> "enum" attr:AttributeSpecifierList n:PQTypeName [EnumAttr] { 0 }
  -> k:ClassKey n:PQTypeName [Class] { 0 }
  -> "enum" n:PQTypeName [Enum] { 0 }
  -> "typename" n:PQTypeName [Typename] { 0 }
  -> k:ClassKey attr:AttributeSpecifier n:PQTypeName [ClassNameAttr] { 0 }
}

nonterm Ellipsis {
  -> "..." [Ellipsis] { 0 }
}

nonterm EmptyDeclaration {
  -> ";" [Empty] { 0 }
}

nonterm EnumSpecifier {
  -> "enum" attr:AttributeSpecifierList n:PQTypeName "{" list:EnumeratorListOpt "}" [NamedEnumAttr] { 0 }
  -> "enum" "{" list:EnumeratorListOpt "}" [Enum] { 0 }
  -> "enum" n:Identifier "{" list:EnumeratorListOpt "}" [NamedEnum] { 0 }
  -> "enum" attr:AttributeSpecifierList "{" list:EnumeratorListOpt "}" [EnumAttr] { 0 }
}

nonterm EnumeratorDefinition {
  -> ename:Identifier eexpr:EnumeratorExpressionOpt [Enum] { 0 }
}

nonterm EnumeratorExpressionOpt {
  -> empty { 0 }
  -> "=" expr:ConstantExpression { 0 }
}

nonterm EnumeratorListOpt {
  fun merge (l, r) { 0 }
  -> empty [Empty] { 0 }
  -> def:EnumeratorDefinition [Head] { 0 }
  -> def:EnumeratorDefinition "," list:EnumeratorListOpt [Tail] { 0 }
}

nonterm ExceptionSpecification {
  -> NoexceptSpecification [NoExcept] { 0 }
  -> "throw" "(" list:TypeIdList ")" [Throw] { 0 }
  -> "throw" "(" ")" [NoThrow] { 0 }
}

nonterm ExceptionSpecificationOpt {
  -> empty { 0 }
  -> s:ExceptionSpecification { 0 }
}

nonterm ExplicitInstantiation {
  -> "extern" "template" d:BlockDeclaration [Extern] { 0 }
  -> "inline" "template" d:BlockDeclaration [Inline] { 0 }
  -> "template" d:BlockDeclaration [Normal] { 0 }
}

nonterm Expression {
  fun merge (l, r) { 0 }
  -> ae:AssignmentExpression [Head] { 0 }
  -> e:Expression "," ae:AssignmentExpression [List] { 0 }
}

nonterm ExpressionList {
  fun merge (l, r) { 0 }
  -> a:AssignmentExpression [Head] { 0 }
  -> e:ExpressionList "," a:AssignmentExpression [Tail] { 0 }
}

nonterm ExpressionListOpt {
  -> empty { 0 }
  -> e:ExpressionList { 0 }
}

nonterm ExpressionStatement {
  -> ";" { 0 }
  -> e:Expression ";" { 0 }
}

nonterm FDDeclarator {
  -> d:Declarator { 0 }
}

nonterm ForConditionOpt {
  -> empty { 0 }
  -> e:Expression { 0 }
}

nonterm ForInitStatement {
  fun merge (l, r) { 0 }
  -> s:ExpressionStatement [Expr] { 0 }
  -> s:SimpleDeclaration [Decl] { 0 }
}

nonterm FunctionBody {
  -> s:CompoundStatement { 0 }
}

nonterm FunctionDefinition {
  fun merge (l, r) { 0 }
  -> r:DeclSpecifier d:FDDeclarator b:FunctionBody [Ordinary] { 0 }
  -> r:DeclSpecifier d:FDDeclarator "try" b:FunctionBody h:HandlerSeq [OrdinaryTry] { 0 }
  -> m:CDtorModifierSeq d:FDDeclarator c:CtorInitialiserOpt b:FunctionBody [CDtorMod] { 0 }
  -> d:FDDeclarator c:CtorInitialiserOpt b:FunctionBody [CDtor] { 0 }
  -> m:CDtorModifierSeq d:FDDeclarator "try" c:CtorInitialiserOpt b:FunctionBody h:HandlerSeq [CDtorTryMod] { 0 }
  -> d:FDDeclarator "try" c:CtorInitialiserOpt b:FunctionBody h:HandlerSeq [CDtorTry] { 0 }
}

nonterm Handler {
  -> "catch" "(" d:HandlerParameter ")" s:CompoundStatement [CatchType] { 0 }
  -> "catch" "(" "..." ")" s:CompoundStatement [CatchAll] { 0 }
}

nonterm HandlerParameter {
  -> s:TypeSpecifier d:UnqualifiedDeclarator [Normal] { 0 }
  -> s:TypeSpecifier d:AbstractDeclaratorOpt [Abstract] { 0 }
}

nonterm HandlerSeq {
  -> h:Handler { 0 }
  -> seq:HandlerSeq h:Handler { 0 }
}

nonterm IdExpression {
  fun merge (l, r) { 0 }
  -> id:PQualifiedId [Id] { 0 }
  -> "::" id:PQualifiedId [GlobalId] { 0 }
}

nonterm Identifier {
  -> n:TOK_NAME { 0 }
}

nonterm IdentifierMemberName {
  fun merge (l, r) { 0 }
  -> n:Identifier "<" list:TemplateArgumentListOpt ">" [Template] { 0 }
  -> n:Identifier [Name] { 0 }
  -> on:OperatorFunctionId [Operator] { 0 }
  -> on:OperatorFunctionId "<" list:TemplateArgumentListOpt ">" [OperatorTemplate] { 0 }
  -> "template" on:OperatorFunctionId "<" list:TemplateArgumentListOpt ">" [TemplateQualOperator] { 0 }
  -> n:Identifier "<" list:TemplateArgumentListOpt ">" "::" rest:SpecialMemberName [TemplateQualifier] { 0 }
  -> n:Identifier "::" rest:SpecialMemberName [Qualifier] { 0 }
}

nonterm IdentifierOpt {
  -> empty { 0 }
  -> n:Identifier { 0 }
}

nonterm ImplIntFunctionDefinition {
  -> m:CFuncModifier_no_inline d:Declarator b:FunctionBody [Func] { 0 }
  -> m1:CFuncModifier_no_inline m2:CFuncModifierSeq d:Declarator b:FunctionBody [ModFunc] { 0 }
  -> "inline" m1:CFuncModifier_no_inline m2:CFuncModifierSeqOpt d:Declarator b:FunctionBody [InlineFunc] { 0 }
}

nonterm ImplicitIntTypeId {
  -> spec:ImplicitIntTypeSpecifier { 0 }
}

nonterm ImplicitIntTypeSpecifier {
  -> m:UberCVQualifierSeq { 0 }
}

nonterm InitDeclarator {
  fun merge (l, r) { 0 }
  -> d:Declarator i:InitialiserOpt [Decl] { 0 }
}

nonterm InitDeclaratorList {
  fun merge (l, r) { 0 }
  -> list:InitDeclaratorList "," attr:AttributeSpecifierList d:InitDeclarator [AttrDecls] { 0 }
  -> list:InitDeclaratorList "," d:InitDeclarator [Tail] { 0 }
  -> d:InitDeclarator [Head] { 0 }
}

nonterm Initialiser {
  -> "=" i:SimpleInitialiserClause [Init] { 0 }
  -> "(" args:ExpressionList ")" [CtorInit] { 0 }
}

nonterm InitialiserClause {
  -> dl:DesignatorList init:SimpleInitialiserClause [DesignatedNoEq] { 0 }
  -> d:Identifier ":" init:SimpleInitialiserClause [GnuDesignated] { 0 }
  -> init:SimpleInitialiserClause [Simple] { 0 }
  -> dl:DesignatorList "=" init:SimpleInitialiserClause [Designated] { 0 }
}

nonterm InitialiserList {
  fun merge (l, r) { 0 }
  -> init:InitialiserClause [Head] { 0 }
  -> list:InitialiserList "," init:InitialiserClause [Tail] { 0 }
}

nonterm InitialiserOpt {
  -> empty { 0 }
  -> i:Initialiser { 0 }
}

nonterm KandRDeclarator {
  -> "*" cv:CVQualifierSeqOpt d:KandRDeclarator [Pointer] { 0 }
  -> d:KandRDirectDeclarator [Direct] { 0 }
}

nonterm KandRDirectDeclarator {
  -> d:KandRIdExpression "(" kAndR_params:KandRIdentifierList ")" [Function] { 0 }
  -> "(" d:KandRIdExpression ")" "(" kAndR_params:KandRIdentifierList ")" [ParenFunction] { 0 }
  -> d:KandRDirectDeclarator "(" params:ParameterDeclarationClause ")" [DirectFunction] { 0 }
  -> d:KandRDirectDeclarator "[" sz:ConstantExpressionOpt "]" [Array] { 0 }
  -> "(" d:KandRDeclarator ")" [Grouping] { 0 }
}

nonterm KandRFunctionDefinition {
  -> rds:DeclSpecifier id:KandRDeclarator ds:KandRSimpleDeclarationSeq b:FunctionBody [Defn] { 0 }
}

nonterm KandRFunctionDefinition_implInt {
  -> id:KandRDeclarator ds:KandRSimpleDeclarationSeq b:FunctionBody [Defn] { 0 }
  -> m:UberModifierSeq id:KandRDeclarator ds:KandRSimpleDeclarationSeq b:FunctionBody [ModDefn] { 0 }
}

nonterm KandRIdExpression {
  -> n:KandRIdentifier { 0 }
}

nonterm KandRIdentifier {
  -> i:Identifier { 0 }
}

nonterm KandRIdentifierList {
  -> i:KandRIdentifier [Head] { 0 }
  -> i:KandRIdentifier "," e:KandRIdentifierList [Tail] { 0 }
}

nonterm KandRInitDeclarator {
  fun merge (l, r) { 0 }
  -> d:Declarator [Declr] { 0 }
}

nonterm KandRInitDeclaratorList {
  -> d:KandRInitDeclarator [Head] { 0 }
  -> d:KandRInitDeclarator "," list:KandRInitDeclaratorList [Tail] { 0 }
}

nonterm KandRSimpleDeclaration {
  -> "register" list:KandRInitDeclaratorList ";" [Declrs] { 0 }
  -> spec:DeclSpecifier list:KandRInitDeclaratorList ";" [Decl] { 0 }
}

nonterm KandRSimpleDeclarationSeq {
  -> s:KandRSimpleDeclaration { 0 }
  -> c:KandRSimpleDeclarationSeq s:KandRSimpleDeclaration { 0 }
}

nonterm LabelAndColon {
  -> n:Identifier ":" attr:AttributeSpecifierList [LabelAttr] { 0 }
  -> n:Identifier ":" [Label] { 0 }
}

nonterm LabelledEmptyStatementList {
  -> n:LabelAndColon s:LabelledEmptyStatementListOpt [Label] { 0 }
  -> "case" e:ConstantExpression ":" s:LabelledEmptyStatementListOpt [Case] { 0 }
  -> "case" e:ConstantExpression "..." e2:ConstantExpression ":" s:LabelledEmptyStatementListOpt [RangeCase] { 0 }
  -> "default" ":" s:LabelledEmptyStatementListOpt [Default] { 0 }
}

nonterm LabelledEmptyStatementListOpt {
  -> empty { 0 }
  -> s:LabelledEmptyStatementList { 0 }
}

nonterm LinkageSpecification {
  -> "extern" n:TOK_STRING_LITERAL "{" tu:TranslationUnit "}" [Linkage] { 0 }
  -> "extern" n:TOK_STRING_LITERAL tf:Declaration [OneLinkage] { 0 }
}

nonterm Literal {
  -> "nullptr" [Nullptr] { 0 }
  -> "false" [False] { 0 }
  -> "true" [True] { 0 }
  -> c:TOK_CHAR_LITERAL [Char] { 0 }
  -> s:StringLiteral [String] { 0 }
  -> f:TOK_FLOAT_LITERAL [Float] { 0 }
  -> i:TOK_INT_LITERAL [Int] { 0 }
}

nonterm MemInitialiser {
  -> mname:MemInitialiserId "(" args:ExpressionListOpt ")" [MemInit] { 0 }
}

nonterm MemInitialiserId {
  -> n:PQTypeName { 0 }
}

nonterm MemInitialiserList {
  -> i:MemInitialiser { 0 }
  -> list:MemInitialiserList "," i:MemInitialiser { 0 }
}

nonterm MemberDeclaration {
  fun merge (l, r) { 0 }
  -> spec:DeclSpecifier decllist:MemberDeclaratorList ";" [Member] { 0 }
  -> spec:DeclSpecifier ";" [InnerSUE] { 0 }
  -> n:PQualifiedId ";" [OldUsingDecl] { 0 }
  -> "using" n:IdExpression ";" [UsingDecl] { 0 }
  -> f:FunctionDefinition [InlineFunc] { 0 }
  -> d:CDtorProtoDecl [CDtor] { 0 }
  -> d:TemplateDeclaration [MemberTemplate] { 0 }
}

nonterm MemberDeclarationSeqOpt {
  fun merge (l, r) { 0 }
  -> empty [Empty] { 0 }
  -> list:MemberDeclarationSeqOpt ";" [Semicolon] { 0 }
  -> list:MemberDeclarationSeqOpt decl:MemberDeclaration [Decl] { 0 }
  -> list:MemberDeclarationSeqOpt k:AccessSpecifier ":" [Access] { 0 }
}

nonterm MemberDeclarator {
  -> n:IdentifierOpt ":" e:ConstantExpression attr:AttributeSpecifierList [Attr] { 0 }
  -> n:IdentifierOpt ":" e:ConstantExpression [Bitfield] { 0 }
  -> d:Declarator "=" e:ConstantExpression [InitDecl] { 0 }
  -> d:Declarator [Decl] { 0 }
}

nonterm MemberDeclaratorList {
  fun merge (l, r) { 0 }
  -> d:MemberDeclarator [Head] { 0 }
  -> list:MemberDeclaratorList "," d:MemberDeclarator [Tail] { 0 }
}

nonterm MemberName {
  fun merge (l, r) { 0 }
  -> n:SpecialMemberName [Name] { 0 }
  -> "::" n:IdentifierMemberName [GlobalName] { 0 }
}

nonterm MemberNameSeq {
  -> n:MemberName [Name] { 0 }
  -> n:MemberNameSeq "." n2:MemberName [Member] { 0 }
  -> n:MemberNameSeq "[" e:Expression "]" [Array] { 0 }
}

nonterm NamespaceDecl {
  -> "using" "namespace" n:IdExpression AttributeSpecifierList ";" [UsingDeclAttr] { 0 }
  -> "using" "namespace" n:IdExpression ";" [UsingDir] { 0 }
  -> "using" n:IdExpression ";" [UsingDecl] { 0 }
  -> "namespace" alias:Identifier "=" orig:IdExpression ";" [Alias] { 0 }
}

nonterm NamespaceDefinition {
  -> "namespace" n:IdentifierOpt attr:AttributeSpecifierList "{" unit:TranslationUnit "}" [NamespaceDefnAttr] { 0 }
  -> "namespace" n:IdentifierOpt "{" unit:TranslationUnit "}" [NamespaceDefn] { 0 }
}

nonterm NewDeclaratorOpt {
  -> empty [Empty] { 0 }
  -> "*" cv:CVQualifierSeqOpt d:NewDeclaratorOpt [Pointer] { 0 }
  -> n:PtrToMemberName "*" cv:CVQualifierSeqOpt d:NewDeclaratorOpt [MemPtr] { 0 }
  -> d:DirectNewDeclarator [Direct] { 0 }
}

nonterm NewExpression {
  fun merge (l, r) { 0 }
  -> c:ColonColonOpt "new" p:NewPlacementOpt t:NewTypeId i:NewInitialiserOpt [Normal] { 0 }
  -> c:ColonColonOpt "new" p:NewPlacementOpt "(" t:TypeId ")" i:NewInitialiserOpt [Parenthesised] { 0 }
}

nonterm NewInitialiserOpt {
  -> empty { 0 }
  -> "(" lst:ExpressionListOpt ")" { 0 }
}

nonterm NewPlacementOpt {
  -> empty { 0 }
  -> "(" lst:ExpressionList ")" { 0 }
}

nonterm NewTypeId {
  -> spec:TypeSpecifier decl:NewDeclaratorOpt [NewTypeId] { 0 }
}

nonterm NoexceptExpression {
  -> "noexcept" "(" e:ParenthesizedExpression ")" { 0 }
}

nonterm NoexceptSpecification {
  -> "noexcept" { 0 }
}

nonterm NonemptyOpConstraints {
  -> ocs:OpConstraints ":" ocl:OpConstraintList [Colon] { 0 }
  -> ocs:OpConstraints "::" ocl:OpConstraintList [ColonColon] { 0 }
}

nonterm OpConstraint {
  -> name:BracketedWordOpt constr:StringLiteral e:ParenthesizedExpressionOpt [Constraint] { 0 }
}

nonterm OpConstraintList {
  -> empty [None] { 0 }
  -> oc:OpConstraint [Head] { 0 }
  -> oc:OpConstraint "," ocl:OpConstraintList [Tail] { 0 }
}

nonterm OpConstraints {
  -> empty { 0 }
  -> ocs:NonemptyOpConstraints { 0 }
}

nonterm Operator {
  -> ">?" [Max] { 0 }
  -> "new" [New] { 0 }
  -> "delete" [Delete] { 0 }
  -> "new" "[" "]" [NewArray] { 0 }
  -> "delete" "[" "]" [DeleteArray] { 0 }
  -> op:OverloadableOp [Op] { 0 }
  -> "<?" [Min] { 0 }
}

nonterm OperatorFunctionId {
  -> "operator" od:Operator { 0 }
}

nonterm OverloadableOp {
  -> "!" [Not] { 0 }
  -> "~" [BitNot] { 0 }
  -> "++" [PlusPlus] { 0 }
  -> "--" [MinusMinus] { 0 }
  -> "+" [Plus] { 0 }
  -> "-" [Minus] { 0 }
  -> "*" [Star] { 0 }
  -> "/" [Div] { 0 }
  -> "%" [Mod] { 0 }
  -> "<<" [Lsh] { 0 }
  -> ">>" [Rsh] { 0 }
  -> "&" [Ampersand] { 0 }
  -> "^" [BitXor] { 0 }
  -> "|" [BitOr] { 0 }
  -> "=" [Assign] { 0 }
  -> "+=" [AddEq] { 0 }
  -> "-=" [SubEq] { 0 }
  -> "*=" [MulEq] { 0 }
  -> "/=" [DivEq] { 0 }
  -> "%=" [ModEq] { 0 }
  -> "<<=" [LshEq] { 0 }
  -> ">>=" [RshEq] { 0 }
  -> "&=" [BitAndEq] { 0 }
  -> "^=" [BitXorEq] { 0 }
  -> "|=" [BitOrEq] { 0 }
  -> "==" [Eq] { 0 }
  -> "!=" [Neq] { 0 }
  -> "<" [Lt] { 0 }
  -> ">" [Gt] { 0 }
  -> "<=" [Le] { 0 }
  -> ">=" [Ge] { 0 }
  -> "&&" [And] { 0 }
  -> "||" [Or] { 0 }
  -> "->" [Arrow] { 0 }
  -> "->*" [ArrowStar] { 0 }
  -> "[" "]" [Brackets] { 0 }
  -> "(" ")" [Parens] { 0 }
  -> "," [Comma] { 0 }
}

nonterm PQClassName {
  fun merge (l, r) { 0 }
  -> n:PQTypeName [Name] { 0 }
}

nonterm PQDtorName {
  fun merge (l, r) { 0 }
  -> "~" n:Identifier [Name] { 0 }
  -> "~" n:Identifier "<" list:TemplateArgumentListOpt ">" [Template] { 0 }
  -> q:Identifier "::" rhs:PQDtorName [QualName] { 0 }
  -> q:Identifier "<" targs:TemplateArgumentListOpt ">" "::" rhs:PQDtorName [QualTemplate] { 0 }
  -> "template" q:Identifier "<" targs:TemplateArgumentListOpt ">" "::" rhs:PQDtorName [TemplateQual] { 0 }
}

nonterm PQTypeName {
  fun merge (l, r) { 0 }
  -> n:PQTypeName_ncc [Local] { 0 }
  -> "::" n:PQTypeName_ncc [Global] { 0 }
}

nonterm PQTypeName_ncc {
  fun merge (l, r) { 0 }
  -> n:Identifier [Id] { 0 }
  -> id:TemplateId [TemplateId] { 0 }
  -> q:Identifier "::" n:PQTypeName_notfirst [Qualified] { 0 }
  -> q:Identifier "<" targs:TemplateArgumentListOpt ">" "::" n:PQTypeName_notfirst [QualifiedTemplateId] { 0 }
}

nonterm PQTypeName_notfirst {
  fun merge (l, r) { 0 }
  -> id:PQTypeName_ncc [Unqual] { 0 }
  -> "template" id:TemplateId [TemplateDecl] { 0 }
  -> "template" q:Identifier "<" targs:TemplateArgumentListOpt ">" "::" n:PQTypeName_notfirst [TemplateQual] { 0 }
}

nonterm PQualifiedId {
  fun merge (l, r) { 0 }
  -> id:UnqualifiedId [Unqual] { 0 }
  -> n:Identifier "::" id:PQualifiedId [Qual] { 0 }
  -> n:Identifier "::" "template" tn:Identifier [TemplateQualNoInst] { 0 }
  -> n:Identifier "<" targs:TemplateArgumentListOpt ">" "::" id:PQualifiedId [Template] { 0 }
  -> "template" n:Identifier "<" targs:TemplateArgumentListOpt ">" "::" id:PQualifiedId [TemplateQual] { 0 }
}

nonterm ParameterDeclaration {
  fun merge (l, r) { 0 }
  -> "register" d:UnqualifiedDeclarator [RegisterImplInt] { 0 }
  -> s:TypeSpecifier pd:ParameterDeclarator [Parm] { 0 }
  -> "register" s:TypeSpecifier pd:ParameterDeclarator [RegParm1] { 0 }
  -> s:TypeSpecifier "register" pd:ParameterDeclarator [RegParm2] { 0 }
  -> d:UnqualifiedDeclarator [ImplInt] { 0 }
}

nonterm ParameterDeclarationClause {
  -> empty { 0 }
  -> p:ParameterDeclarationList { 0 }
}

nonterm ParameterDeclarationList {
  fun merge (l, r) { 0 }
  -> e:Ellipsis [VarArg] { 0 }
  -> d:ParameterDeclaration e:Ellipsis [NamedVarArg] { 0 }
  -> d:ParameterDeclaration [Param] { 0 }
  -> d:ParameterDeclaration "," l:ParameterDeclarationList [Params] { 0 }
}

nonterm ParameterDeclarator {
  fun merge (l, r) { 0 }
  -> d:UnqualifiedDeclarator e:DefaultValueOpt [Decl] { 0 }
  -> d:AbstractDeclaratorOpt e:DefaultValueOpt [AbstractDecl] { 0 }
}

nonterm ParenthesizedExpression {
  -> "(" e:Expression ")" { 0 }
}

nonterm ParenthesizedExpressionOpt {
  -> empty { 0 }
  -> "(" e:Expression ")" { 0 }
}

nonterm PostfixExpression {
  fun merge (l, r) { 0 }
  -> "__builtin_va_arg" "(" e:Expression "," t:TypeId ")" [BuiltinVaArg] { 0 }
  -> "__builtin_offsetof" "(" t:TypeId "," n:MemberNameSeq ")" [BuiltinOffsetof] { 0 }
  -> "__alignof__" "(" t:TypeId ")" [AlignofType] { 0 }
  -> e:PrimaryExpression [PrimaryExpression] { 0 }
  -> a:PostfixExpression "[" e:Expression "]" [ArrayAcc] { 0 }
  -> f:PostfixExpression a:ArgumentList [FunCall] { 0 }
  -> "typename" t:IdExpression a:ArgumentList [DepCtorCall] { 0 }
  -> spec:CtorExpressionType a:ArgumentList [CtorCall] { 0 }
  -> p:PostfixExpression "." n:MemberName [MemberAcc] { 0 }
  -> p:PostfixExpression "->" n:MemberName [PtrAcc] { 0 }
  -> p:PostfixExpression "++" [PostInc] { 0 }
  -> p:PostfixExpression "--" [PostDec] { 0 }
  -> k:CastKeyword "<" t:TypeId ">" "(" e:Expression ")" [Cast] { 0 }
  -> "typeid" "(" e:Expression ")" [TypeidExpr] { 0 }
  -> "typeid" "(" t:TypeId ")" [TypeidType] { 0 }
  -> "__builtin_constant_p" e:ParenthesizedExpression [BuiltinConstantP] { 0 }
  -> "__alignof__" "(" e:Expression ")" [AlignofExpr] { 0 }
  -> "__offsetof__" "(" e:Expression ")" [Offsetof] { 0 }
}

nonterm PrefixDeclarator {
  -> "*" cv:CVQualifierSeqOpt [Ptr] { 0 }
  -> "&" cv:CVQualifierSeqOpt [Re] { 0 }
  -> n:PtrToMemberName "*" cv:CVQualifierSeqOpt [MemPtr] { 0 }
}

nonterm PreprocString {
  -> "__PRETTY_FUNCTION__" [PrettyFuncString] { 0 }
  -> s:TOK_STRING_LITERAL [String] { 0 }
  -> "__FUNCTION__" [FuncString] { 0 }
}

nonterm PrimaryExpression {
  -> "__imag__" e:PrimaryExpression [Imag] { 0 }
  -> "(" t:TypeId ")" i:CompoundInitialiser [CompoundLiteral] { 0 }
  -> e:Literal [Literal] { 0 }
  -> "this" [This] { 0 }
  -> "(" e:Expression ")" [Grouping] { 0 }
  -> e:IdExpression [Variable] { 0 }
  -> "(" cs:CompoundStatement ")" [Statement] { 0 }
  -> "__real__" e:PrimaryExpression [Real] { 0 }
}

nonterm PtrToMemberName {
  fun merge (l, r) { 0 }
  -> n:IdExpression "::" [ClassName] { 0 }
}

nonterm SimpleDeclaration {
  fun merge (l, r) { 0 }
  -> spec:DeclSpecifier decllist:InitDeclaratorList ";" [Defn] { 0 }
  -> spec:DeclSpecifier ";" [Decl] { 0 }
}

nonterm SimpleInitialiserClause {
  -> e:AssignmentExpression [Expr] { 0 }
  -> c:CompoundInitialiser [Compound] { 0 }
}

nonterm SimpleTypeSpecifier {
  -> "_Imaginary" [Imaginary] { 0 }
  -> "char32_t" [Char32T] { 0 }
  -> "char" [Char] { 0 }
  -> "wchar_t" [WCharT] { 0 }
  -> "bool" [Bool] { 0 }
  -> "short" [Short] { 0 }
  -> "int" [Int] { 0 }
  -> "long" [Long] { 0 }
  -> "signed" [Signed] { 0 }
  -> "unsigned" [Unsigned] { 0 }
  -> "float" [Float] { 0 }
  -> "double" [Double] { 0 }
  -> "void" [Void] { 0 }
  -> "char16_t" [Char16T] { 0 }
  -> "_Complex" [Complex] { 0 }
}

nonterm SpecialMemberName {
  fun merge (l, r) { 0 }
  -> n:IdentifierMemberName [Identifier] { 0 }
  -> "template" n:Identifier "<" list:TemplateArgumentListOpt ">" [Template] { 0 }
  -> "~" n:Identifier [Dtor] { 0 }
  -> "~" n:Identifier "<" list:TemplateArgumentListOpt ">" [DtorTemplate] { 0 }
  -> on:ConversionFunctionId [Conversion] { 0 }
  -> "template" n:Identifier "<" list:TemplateArgumentListOpt ">" "::" rest:SpecialMemberName [TemplateQual] { 0 }
}

nonterm Statement {
  fun merge (l, r) { 0 }
  -> "goto" "*" e:Expression ";" [ComputedGoto] { 0 }
  -> k:KandRFunctionDefinition [NestedKandRFunc] { 0 }
  -> m1:UberModifierSeq list:InitDeclaratorList ";" [ImplIntDeclrs] { 0 }
  -> n:NamespaceDecl [Namespace] { 0 }
  -> a:AsmDefinition [Asm] { 0 }
  -> s:TryBlock [Try] { 0 }
  -> d:BlockDeclaration [DeclStmt] { 0 }
  -> "goto" n:Identifier ";" [Goto] { 0 }
  -> "return" ";" [ReturnVoid] { 0 }
  -> "return" e:Expression ";" [ReturnExpr] { 0 }
  -> "continue" ";" [Continue] { 0 }
  -> "break" ";" [Break] { 0 }
  -> "for" "(" s1:ForInitStatement c:ConditionOpt ";" e:ForConditionOpt ")" s2:Statement [For] { 0 }
  -> "do" s:Statement "while" "(" e:Expression ")" ";" [DoWhile] { 0 }
  -> "while" "(" e:Condition ")" s:Statement [While] { 0 }
  -> "switch" "(" e:Condition ")" s:Statement [Switch] { 0 }
  -> "if" "(" e:Condition ")" s1:Statement "else" s2:Statement [IfElse] { 0 }
  -> "if" "(" e:Condition ")" s:Statement [If] { 0 }
  -> s:CompoundStatement [Compound] { 0 }
  -> s:ExpressionStatement [Expr] { 0 }
  -> "default" ":" s:Statement [Default] { 0 }
  -> "case" e:ConstantExpression ":" s:Statement [Case] { 0 }
  -> n:LabelAndColon s:Statement [Label] { 0 }
  -> f:FunctionDefinition [NestedFunc] { 0 }
  -> "case" e:ConstantExpression "..." e2:ConstantExpression ":" s:Statement [CaseRange] { 0 }
}

nonterm StringLiteral {
  -> x:PreprocString { 0 }
  -> xs:StringLiteral x:PreprocString { 0 }
}

nonterm TemplateArgumentList {
  fun merge (l, r) { 0 }
  -> next:TemplateArgumentListContinuation typeid:TypeId "..." [UnpackVarArg] { 0 }
  -> next:TemplateArgumentListContinuation e:AssignmentExpression [NonType] { 0 }
  -> next:TemplateArgumentListContinuation typeid:TypeId [Type] { 0 }
}

nonterm TemplateArgumentListContinuation {
  fun merge (l, r) { 0 }
  -> empty [Head] { 0 }
  -> x:TemplateArgumentList "," [Tail] { 0 }
}

nonterm TemplateArgumentListOpt {
  -> empty { 0 }
  -> list:TemplateArgumentList { 0 }
}

nonterm TemplateDeclaration {
  fun merge (l, r) { 0 }
  -> plist:TemplatePreamble def:FunctionDefinition [Func] { 0 }
  -> plist:TemplatePreamble d:SimpleDeclaration [Decl] { 0 }
  -> plist:TemplatePreamble td:TemplateDeclaration [TMember] { 0 }
  -> plist:TemplatePreamble d:CDtorProtoDecl [CDtor] { 0 }
}

nonterm TemplateId {
  -> n:Identifier "<" list:TemplateArgumentListOpt ">" [Identifier] { 0 }
  -> on:OperatorFunctionId "<" list:TemplateArgumentListOpt ">" [Operator] { 0 }
}

nonterm TemplateParameterList {
  fun merge (l, r) { 0 }
  -> next:TemplateParameterListContinuation "template" "<" pl:TemplateParameterList ">" "class" "..." i:IdentifierOpt [VariadicTemplate] { 0 }
  -> next:TemplateParameterListContinuation ClassOrTypename i:IdentifierOpt t:DefaultTypeOpt [TyParam] { 0 }
  -> next:TemplateParameterListContinuation p:ParameterDeclaration [NonTyParam] { 0 }
  -> next:TemplateParameterListContinuation "template" "<" pl:TemplateParameterList ">" "class" i:IdentifierOpt t:DefaultTemplateOpt [TemplTyParam] { 0 }
  -> next:TemplateParameterListContinuation ClassOrTypename "..." i:IdentifierOpt t:DefaultTypeOpt [Variadic] { 0 }
}

nonterm TemplateParameterListContinuation {
  fun merge (l, r) { 0 }
  -> empty [None] { 0 }
  -> l:TemplateParameterList "," [Some] { 0 }
}

nonterm TemplatePreamble {
  -> "template" "<" plist:TemplateParameterList ">" [Template] { 0 }
  -> "export" "template" "<" plist:TemplateParameterList ">" [ExportTemplate] { 0 }
  -> "template" "<" ">" [ExplSpecTemplate] { 0 }
  -> "export" "template" "<" ">" [ExplSpecExportTemplate] { 0 }
}

nonterm ThrowExpression {
  -> "throw" [ReThrow] { 0 }
  -> "throw" e:AssignmentExpression [Throw] { 0 }
}

nonterm TranslationUnit {
  fun merge (l, r) { 0 }
  -> empty [Empty] { 0 }
  -> xs:TranslationUnit x:Declaration [List] { 0 }
}

nonterm TryBlock {
  -> "try" s:CompoundStatement h:HandlerSeq [Try] { 0 }
}

nonterm TypeId {
  -> spec:TypeSpecifier decl:AbstractDeclaratorOpt [TypeId] { 0 }
}

nonterm TypeIdList {
  -> t:TypeId { 0 }
  -> list:TypeIdList "," t:TypeId { 0 }
}

nonterm TypeName {
  -> n:TOK_TYPE_NAME { 0 }
}

nonterm TypeSpecifier {
  -> cv1:UberCVQualifierSeq te:TypeofTypeSpecifier cv2:UberCVQualifierSeqOpt [QualTypeof] { 0 }
  -> cv1:UberCVQualifierSeq te:DecltypeTypeSpecifier cv2:UberCVQualifierSeqOpt [ModDecltype] { 0 }
  -> n:PQTypeName cv:UberCVQualifierSeqOpt [Name] { 0 }
  -> cv1:UberCVQualifierSeq n:PQTypeName cv2:UberCVQualifierSeqOpt [QualName] { 0 }
  -> k1:SimpleTypeSpecifier m2:UberTypeAndCVQualifierSeqOpt [Simple] { 0 }
  -> m1:UberCVQualifierSeq k1:SimpleTypeSpecifier m2:UberTypeAndCVQualifierSeqOpt [QualSimple] { 0 }
  -> e:ElaboratedOrSpecifier m2:UberCVQualifierSeqOpt [Elab] { 0 }
  -> m1:UberCVQualifierSeq e:ElaboratedOrSpecifier m2:UberCVQualifierSeqOpt [QualElab] { 0 }
  -> te:DecltypeTypeSpecifier cv2:UberCVQualifierSeqOpt [Decltype] { 0 }
  -> te:TypeofTypeSpecifier cv2:UberCVQualifierSeqOpt [Typeof] { 0 }
}

nonterm TypeofExpr {
  -> "__typeof__" "(" e:Expression ")" { 0 }
}

nonterm TypeofType {
  -> "__typeof__" "(" t:TypeId ")" { 0 }
}

nonterm TypeofTypeSpecifier {
  fun merge (l, r) { 0 }
  -> e:TypeofExpr [TypeofExpr] { 0 }
  -> t:TypeofType [TypeofType] { 0 }
}

nonterm UberCVQualifier {
  -> AttributeSpecifier [Attr] { 0 }
  -> "const" [Const] { 0 }
  -> "volatile" [Volatile] { 0 }
  -> "restrict" [Restrict] { 0 }
}

nonterm UberCVQualifierSeq {
  -> u:UberCVQualifier { 0 }
  -> s:UberCVQualifierSeq u:UberCVQualifier { 0 }
}

nonterm UberCVQualifierSeqOpt {
  -> empty { 0 }
  -> s:UberCVQualifierSeq { 0 }
}

nonterm UberModifier {
  -> AttributeSpecifier [Attr] { 0 }
  -> "constexpr" [Constexpr] { 0 }
  -> "volatile" [Volatile] { 0 }
  -> "const" [Const] { 0 }
  -> "typedef" [Typedef] { 0 }
  -> "friend" [Friend] { 0 }
  -> "virtual" [Virtual] { 0 }
  -> "inline" [Inline] { 0 }
  -> "mutable" [Mutable] { 0 }
  -> "extern" [Extern] { 0 }
  -> "static" [Static] { 0 }
  -> "register" [Register] { 0 }
  -> "auto" [Auto] { 0 }
  -> "restrict" [Restrict] { 0 }
}

nonterm UberModifierSeq {
  -> u:UberModifier { 0 }
  -> s:UberModifierSeq u:UberModifier { 0 }
}

nonterm UberModifierSeqOpt {
  -> empty { 0 }
  -> s:UberModifierSeq { 0 }
}

nonterm UberTypeAndCVQualifier {
  -> u:UberCVQualifier [CV] { 0 }
  -> u:SimpleTypeSpecifier [TypeSpec] { 0 }
}

nonterm UberTypeAndCVQualifierSeqOpt {
  -> empty { 0 }
  -> s:UberTypeAndCVQualifierSeqOpt u:UberTypeAndCVQualifier { 0 }
}

nonterm UberTypeAndModifierSeqOpt {
  -> empty [Empty] { 0 }
  -> s:UberTypeAndModifierSeqOpt u:UberModifier [ModSeq] { 0 }
  -> s:UberTypeAndModifierSeqOpt u:SimpleTypeSpecifier [TypeSeq] { 0 }
}

nonterm UnaryExpression {
  fun merge (l, r) { 0 }
  -> "&&" n:Identifier [LabelAddr] { 0 }
  -> e:PostfixExpression [PostfixExpression] { 0 }
  -> e:DeleteExpression [Delete] { 0 }
  -> e:NewExpression [New] { 0 }
  -> "++" e:CastExpression [PreInc] { 0 }
  -> "--" e:CastExpression [PreDec] { 0 }
  -> "sizeof" e:UnaryExpression [SizeofExpr] { 0 }
  -> "sizeof" "(" t:TypeId ")" [SizeofType] { 0 }
  -> "*" e:CastExpression [Deref] { 0 }
  -> "&" e:CastExpression [AddrOf] { 0 }
  -> "+" e:CastExpression [Plus] { 0 }
  -> "-" e:CastExpression [Minus] { 0 }
  -> "!" e:CastExpression [Not] { 0 }
  -> "~" e:CastExpression [BitNot] { 0 }
  -> e:NoexceptExpression [NoExcept] { 0 }
}

nonterm UnqualifiedDeclarator {
  -> d:Declarator { 0 }
}

nonterm UnqualifiedId {
  fun merge (l, r) { 0 }
  -> id:Identifier [Name] { 0 }
  -> on:OperatorFunctionId [Operator] { 0 }
  -> on:ConversionFunctionId [Conversion] { 0 }
  -> id:TemplateId [Template] { 0 }
}

nonterm VirtualOpt {
  -> empty { 0 }
  -> "virtual" { 0 }
}
